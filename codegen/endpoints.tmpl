package {{ .Package }}

import (
	"fmt"
	"context"
	"net/http"
	"github.com/xdrm-io/aicra"
	{{- range $alias, $path := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

type Server interface {
	{{- range .Endpoints }}
	{{- $inStruct  := printf "%sReq" .Name }}
	{{- $outStruct := printf "%sRes" .Name }}
	// {{ .Name }} {{ .Description }}
	{{ .Name }}(context.Context, {{ $inStruct }}) (*{{$outStruct}}, error)
	{{- end }}
}

type route struct {
	method, path string
	fn http.HandlerFunc
}

func routes(impl mapper) []route {
	return []route{
		{{- range .Endpoints }}
		{ "{{.Method}}", "{{.Pattern}}", impl.{{.Name}} },
		{{- end }}
	}
}

func Wire(b *aicra.Builder, impl Server) error {
	mapped := mapper{impl: impl}
	for _, r := range routes(mapped) {
		if err := b.Bind(r.method, r.path, r.fn); err != nil {
			return fmt.Errorf("cannot bind '%s %s': %s", r.method, r.path, err)
		}
	}
	return nil
}

{{- range .Endpoints }}
{{- $inStruct  := printf "%sReq" .Name }}
{{- $outStruct := printf "%sRes" .Name }}
type {{$inStruct}} struct {
	{{- range .Input }}
	{{- if eq .Optional true }}
	{{.Rename}} *{{ getType .ValidatorName $.Validators }}
	{{- else }}
	{{.Rename}} {{ getType .ValidatorName $.Validators }}
	{{- end }}
	{{- end }}
}

type {{$outStruct}} struct {
	{{- range .Output }}
	{{.Rename}} {{ getType .ValidatorName $.Validators }}
	{{- end }}
}
{{- end }}