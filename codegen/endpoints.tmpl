package {{ .Package }}

import (
	"fmt"
	"context"
	"net/http"
	"github.com/xdrm-io/aicra"
	aicraValidator "github.com/xdrm-io/aicra/validator"
	{{- range $alias, $path := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

type Server interface {
	{{- range .Endpoints }}
	{{- $inStruct  := printf "%sReq" .Name }}
	{{- $outStruct := printf "%sRes" .Name }}
	// {{ .Name }} {{ .Description }}
	{{ .Name }}(context.Context, {{ $inStruct }}) (*{{$outStruct}}, error)
	{{- end }}
}

var validators = []aicraValidator.Type{
	{{- range  .Validators }}
	new({{.}}),
	{{- end }}
}

type route struct {
	method, path string
	fn http.HandlerFunc
}

func routes(impl mapper) []route {
	return []route{
		{{- range .Endpoints }}
		{ "{{.Method}}", "{{.Pattern}}", impl.{{.Name}} },
		{{- end }}
	}
}

func Wire(b *aicra.Builder, impl Server) error {
	mapped := mapper{impl: impl}
	for _, r := range routes(mapped) {
		if err := b.Bind(r.method, r.path, r.fn); err != nil {
			return fmt.Errorf("cannot bind '%s %s': %s", r.method, r.path, err)
		}
	}
	return nil
}

{{- range .Endpoints }}
{{- $inStruct  := printf "%sReq" .Name }}
{{- $outStruct := printf "%sRes" .Name }}
{{- if eq (len .Input) 0 }}
type {{$inStruct}} struct {}
{{- else }}
type {{$inStruct}} struct {
	{{- range .Input }}
	{{.Name}} {{.Type}}
	{{- end }}
}
{{- end }}

{{- if eq (len .Output) 0 }}
type {{$outStruct}} struct {}
{{- else }}
type {{$outStruct}} struct {
	{{- range .Output }}
	{{.Name}} {{.Type}}
	{{- end }}
}
{{- end }}
{{- end }}


type mapper struct {
	impl Server
}

{{ range .Endpoints }}
{{- $inStruct  := printf "%sReq" .Name }}
{{- $outStruct := printf "%sRes" .Name }}
func (m mapper) {{ .Name }}(w http.ResponseWriter, r *http.Request) {
	{{- if ne (len .Input) 0 }}
	extract := map[string]string{
		{{- range .Input }}
		"{{.Name}}": "{{.Type}}",
		{{- end }}
	}
	in, err := runtime.Parse(r, validators, extract)
	if err != nil {
		runtime.Respond(w, nil, err)
		return
	}
	req := {{$inStruct}}{
		{{- range .Input }}
		{{- if not .Optional }}
		{{ .Name }}: in["{{.Name}}"].({{.Type}}),
		{{- end }}
		{{- end }}
	}
	{{- range .Input }}
	{{- if .Optional }}
	if v, ok := in["{{.Name}}"] ; ok {
		req.{{.Name}} = &(v.({{ .Type }}))
	}
	{{- end }}
	{{- end }}
	{{- end }}

	{{- if ne (len .Output) 0 }}

	{{- if ne (len .Input) 0 }}
	res, err := m.impl.{{ .Name }}(r.Context(), req)
	{{- else }}
	res, err := m.impl.{{ .Name }}(r.Context(), {{$inStruct}}{})
	{{- end }}
	out := map[string]interface{}{
		{{- range $id, $p := .Output }}
		"{{$id}}": res.{{$p.Name}},
		{{- end }}
	}
	runtime.Respond(w, out, err)

	{{- else  }}

	{{- if ne (len .Input) 0 }}
	_, err = m.impl.{{ .Name }}(r.Context(), req)
	{{- else }}
	_, err := m.impl.{{ .Name }}(r.Context(), {{$inStruct}}{})
	{{- end }}
	runtime.Respond(w, nil, err)

	{{- end }}
}
{{ end }}