// Code generated by aicra DO NOT EDIT.
//go:generate aicragen {{ getConfigRelPath }} .
package {{ .Package }}

import (
	"bytes"
	"fmt"
	"context"
	"net/http"
	"github.com/xdrm-io/aicra"

	{{- range $alias, $path := .Imports }}
	{{- if isEndpointAlias $alias }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
	{{- end }}

	_ "embed"
)

type Server interface {
	{{- range .Endpoints }}
	{{- $inStruct  := printf "%sReq" .Name }}
	{{- $outStruct := printf "%sRes" .Name }}
	// {{ .Name }} {{ .Description }}
	{{ .Name }}(context.Context, {{ $inStruct }}) (*{{$outStruct}}, error)
	{{- end }}
}

type route struct {
	method, path string
	fn http.HandlerFunc
}

func routes(impl mapper) []route {
	return []route{
		{{- range .Endpoints }}
		{ "{{.Method}}", "{{.Pattern}}", impl.{{.Name}} },
		{{- end }}
	}
}

//go:embed {{ getConfigRelPath }}
var config []byte

func New(impl Server) (*aicra.Builder, error) {
	b := &aicra.Builder{}
	if err := b.Setup(bytes.NewReader(config)); err != nil {
		return nil, fmt.Errorf("cannot setup: %w", err)
	}

	mapped := mapper{impl: impl}
	for _, r := range routes(mapped) {
		if err := b.Bind(r.method, r.path, r.fn); err != nil {
			return nil, fmt.Errorf("cannot bind '%s %s': %w", r.method, r.path, err)
		}
	}

	return b, nil
}

{{- range .Endpoints }}
{{- $inStruct  := printf "%sReq" .Name }}
{{- $outStruct := printf "%sRes" .Name }}
{{- if eq (len .Input) 0 }}
type {{$inStruct}} struct {}
{{- else }}
type {{$inStruct}} struct {
	{{- range .Input }}
	{{- if .Optional }}
	{{.Rename}} *{{ getType .ValidatorName $.Validators }}
	{{- else }}
	{{.Rename}} {{ getType .ValidatorName $.Validators }}
	{{- end }}
	{{- end }}
}
{{- end }}

{{- if eq (len .Output) 0 }}
type {{$outStruct}} struct {}
{{- else }}
type {{$outStruct}} struct {
	{{- range .Output }}
	{{.Rename}} {{ getType .ValidatorName $.Validators }}
	{{- end }}
}
{{- end }}
{{- end }}